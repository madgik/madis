Tricky Points
*************

This section includes useful tips to help you understand the functions documentation, to ease 
the shell interaction and intoduce you to some characteristics of the dynamic virtual tables that 
should be stressed from the beginning. 

.. _tipexamples:

Understanding function examples
===============================

While reading each function's description, you will notice examples like this:

    >>> sql("select ifthenelse(1>0,'yes','no') as answer")
    answer
    ------
    yes

This is actually Python code, because examples serve also as test for the system. The string inside the sql function is
the sql query that results to the output in the following lines. Examples include also the column names for clarity, 
while in the interactive shell it is not shown. So the above example in the interactive shell would look like that::

	mterm> select ifthenelse(1>0,'yes','no') as answer;
	yes
	Query executed in 0 min. 0 sec 33 msec


.. _tipparameters:

Understanding function parameters
=================================

**Named parameters**

All types of functions (row, aggregate and virtual table) can take simple or named parameters. 
At simple parameters ordering is important and should follow function's definition while named 
parameters can be placed anywhere in the parameters lists, with few exceptions that it is clearly stated. 
Named parameters are strings (so they must be placed inside quotes) of the format *paramname:paramvalue*.

For example :mod:`~functions.vtable.file` function is declared as::

 file(location[, formatting options])

where *location* is a simple parameter of the file name or network resource to read and *formatting options* is a list of named parameters (eg. parameter *dialect* with values *tsv* or *csv*). So using this function to import a csv file would look like this::
	
	select * from file('myfile','dialect:csv');

Using the inverted syntax of functions (see :ref:`SQL extensions <inversion>`), the query would look like this::
	
	select * from (file 'myfile' dialect:csv);
	
Notice that non named parameters must be quoted again while quoting named parameters is optional and also that parameters are separated with spaces instead of commas. 
If in a named parameter value, space character should be included, quoting must be used. So importing a file that uses space as values delimiter, with inverted syntax would look like this::

	select * from (file 'myfile' 'delimiter: ');

A function definition including the named parameters is :mod:`~functions.vtable.output`::	
	
	output(query:None, file[, formatting options])

Where it takes the named parameter *query* that has no default value. (Usually the value following the ":" character 
of the named parameter in functions' definition, representes the default value).

**The query parameter**

The named parameter *query* shown in the example above, holds for the SQL query that function *output* will execute and take the results to write them at the *file* given. 
When using a function that takes the *query* parameter in inverted syntax (see :ref:`SQL extensions <inversion>`) the *query* keyword can be ommitted and the actual query 
should be placed at the end. For example to output some query's result, do::

	output 'outfile' dialect:tsv select * from table1;

This is actually equivalent to::

	select  * from output('query:select * from table1','outfile','dialect:tsv');

Inverting queries that include the *query* parameter, permits "pipelining" of many virtual table functions, with an easy to read syntax. 
So to re-order a file and add line numbers you can do::

	output 'outfile.csv' rowidvt select * from (file 'infile.csv') order by C2;

Let's look at the details of this query. :mod:`~functions.vtable.file` function reads *infile.csv* and returns the data as a table. Returned data are then ordered by column C2.
The result of the query, *select \* from (file 'infile.csv') order by C2* is the *query* parameter for :mod:`~functions.vtable.rowidvt` functions that adds a *rowid* column to 
the query result that indicates the order of the row in the result and not in the initial table. The result of :mod:`~functions.vtable.rowidvt` function is "fed" 
into :mod:`~functions.vtable.output` which writes the result to the *outfile.csv* file.


.. _tipreturntypes:

Understanding function return types
===================================

To understand how function return types works, make sure you understand how `SQLite types <http://www.sqlite.org/datatype3.html>`_ work. 
The return type of the row and aggregate Madis functions refers to the storage class usually returned by the function. 
Virtual table functions return a table that has a static or dynamic schema with column names and `types affinity <http://www.sqlite.org/datatype3.html#affinity>`_. 
To make more clear the difference of the returned types of row/aggregate functions and virtual table functions consider the following example::

	mterm> select * from (select kwnum('lol') as a) where a=='1';
	Query executed in 0 min. 0 sec 17 msec

Here :func:`~functions.row.text.kwnum` function returns the number of keywords of the 'lol' string which is an integer. Although it is an integer, meaning column a is integer, 
the literal text is not converted to integer, so the condition fails. In contrast at the following example using the built in SQLite function *cast* an integer type affinity 
is suggested so the text literal '1' is converted to integer and the condition is evaluated to true.

::
	
	mterm> select * from (select cast(kwnum('lol') as int) as a) where a=='1';
	1
	Query executed in 0 min. 0 sec 21 msec

The same result could be reached using a virtual table function, eg. :mod:`~functions.vtable.typing` or :mod:`~functions.vtable.setschema`. 

So the returned values from row and aggregate functions, even :ref:`multisets <tutmultiset>` do not imply data affinity. ONLY in ....

******CHANGE expand not to produce affinity or not****************


.. _tipshell:

Shell interaction
=================


Except of the shell commands that 
**Autocomplete **

Names , coltypes

toggle  tracing

toggle vtdebug

------------------

Auta mallon se flow pio polu i 
use it as a flow engine
----------------------------
logging???
setexecdb
settings
variables???

.. _tipemptyschema:

Empty schema exception
======================

A price to pay when using virtual tables with dynamic schema creation is that if no data are provided, for example an empty file for :mod:`~functions.vtable.file` function or
a query that returns no rows for the virtual tables that take input *query* (eg. :mod:`~functions.vtable.cache` function). Doing so will result to an exception::

	mterm> select * from (cache select 5 as a where a!=5);
	Madis SQLError: operator cache: Cannot initialise dynamic schema virtual table without data


To avoid this issue, especially in automatic flow execution where a flow crash is desirable because a query does not have results, :mod:`~functions.vtable.file` function can be used.
*Setschema* is virtual table function that defines a schema and in case of non empty resultset can be used to project, rename and typecast inner query columns, while in case of an empty 
resultset works as static schema definition. 

::

	mterm> select * from (setschema 'a' cache select 5 as a where a!=5);
	Query executed in 0 min. 0 sec 62 msec

So in the example above since *cache* function as a dynamic schema function can result to an empty schema exception, applying on the query setschema function with the desirable schema
(column a with NONE type) the proble is eliminated.

Possible causes of this phenomenon are also :ref:`multiset <tutmultiset>` functions that are actually implemented with :mod:`~functions.vtable.expand` virtual table function.

.. _tipefficiencyvt:

Efficiency in streaming virtual tables
======================================

Virtual table functions that work as streams do not materialise the data before returning them, they just produce them on demand. 
So making a join between streaming virtual tables for many data is not a good idea as the data will be re-produced over and over again. Using 
:ref:`cache <tutcache>` virtual table function at one of the *streaming* queries will significantly increase performance.


